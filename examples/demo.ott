--
-- demo.ott - playing with opetopic type theory
--

let identity : (X : Type) -> X -> X
    	     = \X. \x. x ;

let Arrow : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> Type
    	  = \X. \x. \y. Cell X [ box y (pt (obj x)) ] ;

let Loop : (X : Cat) -> (x : Obj X) -> (f : Arrow X x x) -> Type
    	 = \X. \x. \f. Cell X [ obj x ]>> [ box f leaf ] ;

let TwoGlob : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (f : Arrow X x y) -> (g : Arrow X x y) -> Type
    	    = \X. \x. \y. \f. \g. Cell X [ box y (pt (obj x)) ]>> [ box g (node (dot f) (pt leaf)) ] ;

let Simplex : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (z : Obj X) -> (f : Arrow X x y) -> (g : Arrow X y z) -> (h : Arrow X x z) -> Type
    	    = \X. \x. \y. \z. \f. \g. \h. Cell X [ box z (pt (box y (pt (obj x)))) ]>> [ box h (node (dot g) (pt (node (dot f) (pt leaf)))) ] ; 

let id : (X : Cat) -> (x : Obj X) -> Arrow X x x
       = \X. \x. comp X [ obj x ]>> { leaf } ;

let refl : (X : Cat) -> (x : Obj X) -> Loop X x (id X x)
    	 = \X. \x. fill X [ obj x ]>> { leaf } ;

let comp : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (z : Obj X) -> (f : Arrow X x y) -> (g : Arrow X y z) -> Arrow X x z
    	 = \X. \x. \y. \z. \f. \g. comp X [ box z (pt (box y (pt (obj x)))) ]>> { node g (pt (node f (pt leaf))) } ;

let compFill : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (z : Obj X) -> (f : Arrow X x y) -> (g : Arrow X y z) -> Simplex X x y z f g (comp X x y z f g)
    	     = \X. \x. \y. \z. \f. \g. fill X [ box z (pt (box y (pt (obj x)))) ]>> { node g (pt (node f (pt leaf))) } ;

let compWithIdent : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (f : Arrow X x y) -> Arrow X x y
     		  = \X. \x. \y. \f. comp X x x y (id X x) f ;

let leftExtTest : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (f : Arrow X x y) -> Type
     		= \X. \x. \y. \f. isLeftExt f ; 

let rightExtTest : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (f : Arrow X x y) -> Type
     		= \X. \x. \y. \f. isRightExt f # ; 

let balancedTest : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (z : Obj X) -> (f : Arrow X x y) -> Type
    		 = \X. \x. \y. \z. \f. isBalanced X [ box z (pt (box y (pt (obj x)))) ]>> { node Empty (pt (node f (pt leaf))) } ;

tt
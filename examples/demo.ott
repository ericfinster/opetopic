--
-- demo.ott - playing with opetopic type theory
--

let identity : (X : Type) -> X -> X
    	     = \X. \x. x ;

let catTest : (X : Cat) -> Cat
    	    = \X. X ;

let objTest : (X : Cat) -> (x : Obj X) -> Obj X
    	    = \X. \x. x ;

let cellTest : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> Type
    	     = \X. \x. \y. Cell X [ box y (pt (obj x)) ] ;

let bigTest : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (z : Obj X) -> 
    	      (f : Cell X [ box y (pt (obj x)) ]) -> 
	      (g : Cell X [ box z (pt (obj y)) ]) -> 
	      (h : Cell X [ box z (pt (obj x)) ]) -> (alpha : Cell X [ box z (pt (box y (pt (obj x)))) ]>> [ box h (node (dot g) (pt (node (dot f) (pt leaf)))) ]) -> Unit
	    = \X. \x. \y. \z. \f. \g. \h. \alpha. tt ;

let compTest : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (z : Obj X) -> 
    	       (f : Cell X [ box y (pt (obj x)) ]) -> 
	       (g : Cell X [ box z (pt (obj y)) ]) -> Cell X [ box z (pt (obj x)) ]
	     = \X. \x. \y. \z. \f. \g. comp X [ box z (pt (box y (pt (obj x)))) ]>> { node g (pt (node f (pt leaf))) } ;

let ident : (X : Cat) -> (x : Obj X) -> Cell X [ box x (pt (obj x)) ]
    	  = \X. \x. comp X [ obj x ]>> { leaf } ;

let refl : (X : Cat) -> (x : Obj X) -> Cell X [ obj x ]>> [ box (ident X x) leaf ]
    	 = \X. \x. fill X [ obj x ]>> { leaf } ;

let compWithIdent : (X : Cat) -> (x : Obj X) -> (y : Obj X) -> (f : Cell X [ box y (pt (obj x)) ]) -> Cell X [ box y (pt (obj x)) ]
    		  = \X. \x. \y. \f. comp X [ box y (pt (box x (pt (obj x)))) ]>> { node f (pt (node (ident X x) (pt leaf))) } ;

tt
--
-- demo.ott - playing with opetopic type theory
--

let identity : (X : Type) -> X -> X
             = \X. \x. x ; 

let catTest : Type
            = Cat ;

let obTest : (X : Cat) -> Type
           = \X. Ob X ;

let Arrow : (X : Cat) -> (x : Ob X) -> (y : Ob X) -> Type
          = \X. \x. \y. Cell X 1 (pt x) y ;  

let Drop : (X : Cat) -> (x : Ob X) -> (f : Arrow X x x) -> Type
         = \X. \x. \f. Cell X 2 lf f ;

let Simplex : (X : Cat) -> (x : Ob X) -> (y : Ob X) -> (z : Ob X) -> (f : Arrow X x y) -> (g : Arrow X y z) -> (h : Arrow X x z) -> Type
            = \X. \x. \y. \z. \f. \g. \h. Cell X 2 (nd g (pt (nd f (pt lf)))) h ;

let rTest : (X : Cat) -> (x : Ob X) -> Arrow X x x
          = \X. \x. refl X x ;

let dTest : (X : Cat) -> (x : Ob X) -> Drop X x (rTest X x)
          = \X. \x. drop X x ;

let cTest : (X : Cat) -> (x : Ob X) -> (y : Ob X) -> (z : Ob X) -> (f : Arrow X x y) -> (g : Arrow X y z) -> Arrow X x z
    	  = \X. \x. \y. \z. \f. \g. comp X 1 (nd g (pt (nd f (pt lf)))) ;

let fTest : (X : Cat) -> (x : Ob X) -> (y : Ob X) -> (z : Ob X) -> (f : Arrow X x y) -> (g : Arrow X y z) -> Simplex X x y z f g (cTest X x y z f g)
    	  = \X. \x. \y. \z. \f. \g. fill X 1 (nd g (pt (nd f (pt lf)))) ;

tt